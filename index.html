<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>玫瑰花束（纯网页源码）</title>
  <style>
    html, body { height: 100%; margin: 0; background: #000; overflow: hidden; }
    canvas { display: block; }
    .hud{
      position: fixed; left: 0; right: 0; top: 0;
      padding: 14px 16px;
      font-family: ui-sans-serif, system-ui, -apple-system, "PingFang SC", "Microsoft YaHei";
      color: rgba(255,255,255,.92);
      pointer-events: none;
      text-align: center;
      text-shadow: 0 0 10px rgba(255,80,160,.55), 0 0 30px rgba(255,80,160,.25);
    }
    .hud h1{
      margin: 0;
      font-size: 28px;
      letter-spacing: 4px;
      font-weight: 800;
    }
    .hud p{
      margin: 6px 0 0;
      opacity: .75;
      font-size: 14px;
      letter-spacing: 1px;
    }
    .tip{
      position: fixed; bottom: 14px; left: 14px;
      color: rgba(255,255,255,.7);
      font-family: ui-sans-serif, system-ui, -apple-system, "PingFang SC", "Microsoft YaHei";
      font-size: 12px;
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.12);
      padding: 10px 12px;
      border-radius: 12px;
      backdrop-filter: blur(8px);
    }
  </style>
</head>
<body>
  <div class="hud">
    <h1>玫瑰花束代码</h1>
    <p>附源码 · 纯网页（HTML/CSS/JS）</p>
  </div>
  <div class="tip">拖拽旋转视角 · 滚轮缩放 · 手机可双指缩放</div>

  <!-- three + postprocessing（CDN 版，直接可用） -->
  <script type="module">
    import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";
    import { OrbitControls } from "https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js";
    import { EffectComposer } from "https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/EffectComposer.js";
    import { RenderPass } from "https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/RenderPass.js";
    import { UnrealBloomPass } from "https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/UnrealBloomPass.js";

    // ---------- 基础场景 ----------
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(innerWidth, innerHeight);
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.15;
    document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene();

    const camera = new THREE.PerspectiveCamera(45, innerWidth / innerHeight, 0.1, 200);
    camera.position.set(0, 6.5, 18);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.06;
    controls.autoRotate = true;
    controls.autoRotateSpeed = 0.55;
    controls.minDistance = 10;
    controls.maxDistance = 30;
    controls.maxPolarAngle = Math.PI * 0.58;

    // ---------- 灯光 ----------
    // 霓虹效果主要靠 Bloom，这里只要柔和补光
    scene.add(new THREE.AmbientLight(0xffffff, 0.25));

    const key = new THREE.PointLight(0xff4aa6, 2.2, 60);
    key.position.set(0, 14, 10);
    scene.add(key);

    const rim = new THREE.PointLight(0xffb3da, 1.4, 60);
    rim.position.set(-12, 6, -10);
    scene.add(rim);

    // ---------- 后期 Bloom ----------
    const composer = new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene, camera));
    const bloom = new UnrealBloomPass(
      new THREE.Vector2(innerWidth, innerHeight),
      1.35,   // strength
      0.55,   // radius
      0.08    // threshold
    );
    composer.addPass(bloom);

    // ---------- 背景星尘 ----------
    function makeStarDust(count = 1800) {
      const geo = new THREE.BufferGeometry();
      const pos = new Float32Array(count * 3);
      const col = new Float32Array(count * 3);

      for (let i = 0; i < count; i++) {
        const r = 70 * Math.random();
        const t = Math.random() * Math.PI * 2;
        const p = Math.acos(2 * Math.random() - 1);

        pos[i*3+0] = r * Math.sin(p) * Math.cos(t);
        pos[i*3+1] = (Math.random() - 0.5) * 45;
        pos[i*3+2] = r * Math.sin(p) * Math.sin(t);

        const c = new THREE.Color().setHSL(0.92 + Math.random()*0.05, 0.85, 0.6 + Math.random()*0.2);
        col[i*3+0] = c.r; col[i*3+1] = c.g; col[i*3+2] = c.b;
      }

      geo.setAttribute("position", new THREE.BufferAttribute(pos, 3));
      geo.setAttribute("color", new THREE.BufferAttribute(col, 3));

      const mat = new THREE.PointsMaterial({
        size: 0.06,
        vertexColors: true,
        transparent: true,
        opacity: 0.65,
        depthWrite: false
      });

      const pts = new THREE.Points(geo, mat);
      pts.position.y = 6;
      scene.add(pts);
      return pts;
    }
    const stars = makeStarDust();

    // ---------- 通用发光材质 ----------
    const neonPink = new THREE.MeshStandardMaterial({
      color: 0xff3f9a,
      emissive: 0xff2a86,
      emissiveIntensity: 1.3,
      metalness: 0.35,
      roughness: 0.25
    });

    const neonWhite = new THREE.MeshStandardMaterial({
      color: 0xffffff,
      emissive: 0xffb6de,
      emissiveIntensity: 1.1,
      metalness: 0.2,
      roughness: 0.15
    });

    const stemMat = new THREE.MeshStandardMaterial({
      color: 0x2a2a2a,
      emissive: 0x0b0b0b,
      emissiveIntensity: 0.2,
      metalness: 0.05,
      roughness: 0.75
    });

    // ---------- 玫瑰（由多片花瓣拟合） ----------
    function makeRose({ petals = 34, radius = 1.4, height = 1.0, tint = 0xff3f9a } = {}) {
      const g = new THREE.Group();

      // 花心小球
      const core = new THREE.Mesh(
        new THREE.SphereGeometry(0.22, 24, 24),
        new THREE.MeshStandardMaterial({
          color: tint,
          emissive: 0xff2a86,
          emissiveIntensity: 1.4,
          metalness: 0.4,
          roughness: 0.18
        })
      );
      core.position.y = 0.2;
      g.add(core);

      // 单片花瓣：弯曲的薄片（用平面 + 旋转缩放实现视觉弧度）
      const petalGeo = new THREE.PlaneGeometry(1.0, 1.3, 1, 1);
      petalGeo.translate(0, 0.55, 0);

      for (let i = 0; i < petals; i++) {
        const layer = i / petals;
        const angle = i * (Math.PI * 2 / 9) + layer * 1.2;
        const r = radius * (0.15 + layer);
        const y = height * (layer - 0.2);

        const mat = new THREE.MeshStandardMaterial({
          color: tint,
          emissive: 0xff2a86,
          emissiveIntensity: 1.15,
          metalness: 0.35,
          roughness: 0.22,
          side: THREE.DoubleSide,
          transparent: true,
          opacity: 0.92
        });

        const petal = new THREE.Mesh(petalGeo, mat);

        // 摆放花瓣：围绕中心
        petal.position.set(
          Math.cos(angle) * r * 0.55,
          y * 0.9 + 0.35,
          Math.sin(angle) * r * 0.55
        );

        // 朝外 + 微卷边（靠 rotation 和 scale 做视觉弧度）
        petal.rotation.y = angle + Math.PI;
        petal.rotation.x = -0.25 - layer * 0.6;
        petal.rotation.z = (Math.random() - 0.5) * 0.5;

        const s = 0.35 + layer * 0.9;
        petal.scale.set(0.
