<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>玫瑰花束（纯网页源码）</title>
  <style>
    html, body { height: 100%; margin: 0; background: #000; overflow: hidden; }
    canvas { display: block; }
    .hud{
      position: fixed; left: 0; right: 0; top: 0;
      padding: 14px 16px;
      font-family: ui-sans-serif, system-ui, -apple-system, "PingFang SC", "Microsoft YaHei";
      color: rgba(255,255,255,.92);
      pointer-events: none;
      text-align: center;
      text-shadow: 0 0 10px rgba(255,80,160,.55), 0 0 30px rgba(255,80,160,.25);
    }
    .hud h1{
      margin: 0;
      font-size: 28px;
      letter-spacing: 4px;
      font-weight: 800;
    }
    .hud p{
      margin: 6px 0 0;
      opacity: .75;
      font-size: 14px;
      letter-spacing: 1px;
    }
    .tip{
      position: fixed; bottom: 14px; left: 14px;
      color: rgba(255,255,255,.7);
      font-family: ui-sans-serif, system-ui, -apple-system, "PingFang SC", "Microsoft YaHei";
      font-size: 12px;
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.12);
      padding: 10px 12px;
      border-radius: 12px;
      backdrop-filter: blur(8px);
    }
  </style>
</head>
<body>
  <div class="hud">
    <h1>玫瑰花束代码</h1>
    <p>附源码 · 纯网页（HTML/CSS/JS）</p>
  </div>
  <div class="tip">拖拽旋转视角 · 滚轮缩放 · 手机可双指缩放</div>

  <!-- three + postprocessing（CDN 版，直接可用） -->
  <script type="module">
    import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";
    import { OrbitControls } from "https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js";
    import { EffectComposer } from "https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/EffectComposer.js";
    import { RenderPass } from "https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/RenderPass.js";
    import { UnrealBloomPass } from "https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/UnrealBloomPass.js";

    // ---------- 基础场景 ----------
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(innerWidth, innerHeight);
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.15;
    document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene();

    const camera = new THREE.PerspectiveCamera(45, innerWidth / innerHeight, 0.1, 200);
    camera.position.set(0, 6.5, 18);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.06;
    controls.autoRotate = true;
    controls.autoRotateSpeed = 0.55;
    controls.minDistance = 10;
    controls.maxDistance = 30;
    controls.maxPolarAngle = Math.PI * 0.58;

    // ---------- 灯光 ----------
    // 霓虹效果主要靠 Bloom，这里只要柔和补光
    scene.add(new THREE.AmbientLight(0xffffff, 0.25));

    const key = new THREE.PointLight(0xff4aa6, 2.2, 60);
    key.position.set(0, 14, 10);
    scene.add(key);

    const rim = new THREE.PointLight(0xffb3da, 1.4, 60);
    rim.position.set(-12, 6, -10);
    scene.add(rim);

    // ---------- 后期 Bloom ----------
    const composer = new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene, camera));
    const bloom = new UnrealBloomPass(
      new THREE.Vector2(innerWidth, innerHeight),
      1.35,   // strength
      0.55,   // radius
      0.08    // threshold
    );
    composer.addPass(bloom);

    // ---------- 背景星尘 ----------
    function makeStarDust(count = 1800) {
      const geo = new THREE.BufferGeometry();
      const pos = new Float32Array(count * 3);
      const col = new Float32Array(count * 3);

      for (let i = 0; i < count; i++) {
        const r = 70 * Math.random();
        const t = Math.random() * Math.PI * 2;
        const p = Math.acos(2 * Math.random() - 1);

        pos[i*3+0] = r * Math.sin(p) * Math.cos(t);
        pos[i*3+1] = (Math.random() - 0.5) * 45;
        pos[i*3+2] = r * Math.sin(p) * Math.sin(t);

        const c = new THREE.Color().setHSL(0.92 + Math.random()*0.05, 0.85, 0.6 + Math.random()*0.2);
        col[i*3+0] = c.r; col[i*3+1] = c.g; col[i*3+2] = c.b;
      }

      geo.setAttribute("position", new THREE.BufferAttribute(pos, 3));
      geo.setAttribute("color", new THREE.BufferAttribute(col, 3));

      const mat = new THREE.PointsMaterial({
        size: 0.06,
        vertexColors: true,
        transparent: true,
        opacity: 0.65,
        depthWrite: false
      });

      const pts = new THREE.Points(geo, mat);
      pts.position.y = 6;
      scene.add(pts);
      return pts;
    }
    const stars = makeStarDust();

    // ---------- 通用发光材质 ----------
    const neonPink = new THREE.MeshStandardMaterial({
      color: 0xff3f9a,
      emissive: 0xff2a86,
      emissiveIntensity: 1.3,
      metalness: 0.35,
      roughness: 0.25
    });

    const neonWhite = new THREE.MeshStandardMaterial({
      color: 0xffffff,
      emissive: 0xffb6de,
      emissiveIntensity: 1.1,
      metalness: 0.2,
      roughness: 0.15
    });

    const stemMat = new THREE.MeshStandardMaterial({
      color: 0x2a2a2a,
      emissive: 0x0b0b0b,
      emissiveIntensity: 0.2,
      metalness: 0.05,
      roughness: 0.75
    });

    // ---------- 玫瑰（由多片花瓣拟合） ----------
    function makeRose({ petals = 34, radius = 1.4, height = 1.0, tint = 0xff3f9a } = {}) {
      const g = new THREE.Group();

      // 花心小球
      const core = new THREE.Mesh(
        new THREE.SphereGeometry(0.22, 24, 24),
        new THREE.MeshStandardMaterial({
          color: tint,
          emissive: 0xff2a86,
          emissiveIntensity: 1.4,
          metalness: 0.4,
          roughness: 0.18
        })
      );
      core.position.y = 0.2;
      g.add(core);

      // 单片花瓣：弯曲的薄片（用平面 + 旋转缩放实现视觉弧度）
      const petalGeo = new THREE.PlaneGeometry(1.0, 1.3, 1, 1);
      petalGeo.translate(0, 0.55, 0);

      for (let i = 0; i < petals; i++) {
        const layer = i / petals;
        const angle = i * (Math.PI * 2 / 9) + layer * 1.2;
        const r = radius * (0.15 + layer);
        const y = height * (layer - 0.2);

        const mat = new THREE.MeshStandardMaterial({
          color: tint,
          emissive: 0xff2a86,
          emissiveIntensity: 1.15,
          metalness: 0.35,
          roughness: 0.22,
          side: THREE.DoubleSide,
          transparent: true,
          opacity: 0.92
        });

        const petal = new THREE.Mesh(petalGeo, mat);

        // 摆放花瓣：围绕中心
        petal.position.set(
          Math.cos(angle) * r * 0.55,
          y * 0.9 + 0.35,
          Math.sin(angle) * r * 0.55
        );

        // 朝外 + 微卷边（靠 rotation 和 scale 做视觉弧度）
        petal.rotation.y = angle + Math.PI;
        petal.rotation.x = -0.25 - layer * 0.6;
        petal.rotation.z = (Math.random() - 0.5) * 0.5;

        const s = 0.35 + layer * 0.9;
        petal.scale.set(0.75 * s, 0.75 * s, 1);

        g.add(petal);
      }

      // 外圈“亮边”装饰（增强通透感）
      const ring = new THREE.Mesh(
        new THREE.TorusGeometry(radius * 0.55, 0.03, 10, 120),
        neonWhite
      );
      ring.rotation.x = Math.PI / 2;
      ring.position.y = 0.55;
      g.add(ring);

      g.scale.set(0.9, 0.9, 0.9);
      return g;
    }

    // ---------- 花束（多朵玫瑰 + 枝干） ----------
    function makeBouquet() {
      const bouquet = new THREE.Group();

      // 花朵阵列
      const roses = [
        { x: -1.2, y: 3.9, z: 0.1, s: 1.05 },
        { x:  0.2, y: 4.3, z: 0.6, s: 1.00 },
        { x:  1.3, y: 3.7, z: -0.2, s: 0.95 },
        { x: -0.2, y: 3.4, z: -0.9, s: 0.9 },
      ];

      roses.forEach((r, idx) => {
        const rose = makeRose({
          petals: 34 + idx * 3,
          radius: 1.35,
          height: 1.05,
          tint: 0xff3f9a
        });
        rose.position.set(r.x, r.y, r.z);
        rose.rotation.y = (idx - 1.5) * 0.35;
        rose.rotation.x = (Math.random() - 0.5) * 0.15;
        rose.scale.multiplyScalar(r.s);
        bouquet.add(rose);
      });

      // 枝干（几根细圆柱组合）
      const stemGeo = new THREE.CylinderGeometry(0.06, 0.08, 6.2, 18);
      for (let i = 0; i < 5; i++) {
        const stem = new THREE.Mesh(stemGeo, stemMat);
        stem.position.set((Math.random()-0.5)*0.9, 1.15, (Math.random()-0.5)*0.7);
        stem.rotation.z = (Math.random()-0.5)*0.35;
        stem.rotation.x = (Math.random()-0.5)*0.12;
        bouquet.add(stem);
      }

      // 花束底部小绑带（用小圆环）
      const tie = new THREE.Mesh(
        new THREE.TorusGeometry(0.55, 0.06, 16, 60),
        neonPink
      );
      tie.position.set(0, 0.2, 0);
      tie.rotation.x = Math.PI/2;
      bouquet.add(tie);

      bouquet.position.y = -0.2;
      return bouquet;
    }

    const bouquet = makeBouquet();
    scene.add(bouquet);

    // ---------- 旋转光环（带刺） ----------
    function makeThornRing(radius = 6.2, tube = 0.07, thornCount = 64) {
      const ring = new THREE.Group();

      const torus = new THREE.Mesh(
        new THREE.TorusGeometry(radius, tube, 18, 260),
        new THREE.MeshStandardMaterial({
          color: 0xffffff,
          emissive: 0xffb6de,
          emissiveIntensity: 1.25,
          metalness: 0.55,
          roughness: 0.18
        })
      );
      torus.rotation.x = Math.PI / 2;
      ring.add(torus);

      // 刺：小圆锥均匀分布
      const thornGeo = new THREE.ConeGeometry(0.06, 0.28, 12);
      for (let i = 0; i < thornCount; i++) {
        const a = i * (Math.PI * 2 / thornCount);
        const thorn = new THREE.Mesh(thornGeo, neonWhite);

        thorn.position.set(Math.cos(a) * radius, 0, Math.sin(a) * radius);

        // 朝外
        thorn.lookAt(new THREE.Vector3(0, 0, 0));
        thorn.rotateX(Math.PI); // 让尖端朝外
        thorn.rotateZ((Math.random()-0.5)*0.4);

        ring.add(thorn);
      }

      return ring;
    }

    const ringA = makeThornRing(6.5, 0.07, 72);
    const ringB = makeThornRing(4.8, 0.06, 56);

    ringA.position.y = 2.2;
    ringB.position.y = 2.0;

    ringA.rotation.z = 0.25;
    ringB.rotation.x = 0.35;

    scene.add(ringA, ringB);

    // ---------- 飘落花瓣/爱心粒子 ----------
    function makeFloatBits(count = 180) {
      const geo = new THREE.BufferGeometry();
      const pos = new Float32Array(count * 3);
      const vel = new Float32Array(count * 3);

      for (let i = 0; i < count; i++) {
        pos[i*3+0] = (Math.random()-0.5) * 18;
        pos[i*3+1] = Math.random() * 14;
        pos[i*3+2] = (Math.random()-0.5) * 18;

        vel[i*3+0] = (Math.random()-0.5) * 0.015;
        vel[i*3+1] = 0.01 + Math.random() * 0.02;
        vel[i*3+2] = (Math.random()-0.5) * 0.015;
      }

      geo.setAttribute("position", new THREE.BufferAttribute(pos, 3));
      geo.setAttribute("velocity", new THREE.BufferAttribute(vel, 3));

      const mat = new THREE.PointsMaterial({
        size: 0.16,
        color: 0xff6bb9,
        transparent: true,
        opacity: 0.72,
        depthWrite: false
      });

      const pts = new THREE.Points(geo, mat);
      scene.add(pts);

      return pts;
    }

    const bits = makeFloatBits(220);

    // ---------- 动画循环 ----------
    const clock = new THREE.Clock();

    function tick() {
      const t = clock.getElapsedTime();

      // 花束轻微呼吸 + 旋转
      bouquet.rotation.y = t * 0.35;
      bouquet.position.y = -0.2 + Math.sin(t * 1.3) * 0.06;

      // 双环旋转（类似图里轨道）
      ringA.rotation.y = t * 0.75;
      ringA.rotation.z = 0.25 + Math.sin(t * 0.9) * 0.06;

      ringB.rotation.y = -t * 0.95;
      ringB.rotation.x = 0.35 + Math.cos(t * 0.8) * 0.06;

      // 背景星尘缓慢转
      stars.rotation.y = t * 0.02;

      // 粒子上浮 + 回收
      const p = bits.geometry.attributes.position;
      const v = bits.geometry.attributes.velocity;

      for (let i = 0; i < p.count; i++) {
        p.array[i*3+0] += v.array[i*3+0] + Math.sin(t + i) * 0.0006;
        p.array[i*3+1] += v.array[i*3+1] * 0.35;
        p.array[i*3+2] += v.array[i*3+2] + Math.cos(t + i) * 0.0006;

        // 飘到太高就重置到下方
        if (p.array[i*3+1] > 16) {
          p.array[i*3+0] = (Math.random()-0.5) * 18;
          p.array[i*3+1] = -2 - Math.random() * 2;
          p.array[i*3+2] = (Math.random()-0.5) * 18;
        }
      }
      p.needsUpdate = true;

      controls.update();
      composer.render();
      requestAnimationFrame(tick);
    }
    tick();

    // ---------- 自适应 ----------
    addEventListener("resize", () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
      composer.setSize(innerWidth, innerHeight);
    });
  </script>
</body>
</html>

